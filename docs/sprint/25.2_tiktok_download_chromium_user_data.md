# Sprint 25.2 - TikTok Download Chromium User Data

## Goal
Provide a persistent Chromium user-data workflow that headless TikTok download strategies can reuse, eliminating mandatory headful runs while maintaining anti-detection guarantees.

## Background
- TikTok downloads currently rely on `ChromiumDownloadStrategy` (`app/services/tiktok/download/strategies/chromium.py`), which launches DynamicFetcher with a fresh, temporary profile.
- The Camoufox stack already offers mature user-data management via `CAMOUFOX_USER_DATA_DIR` (see Sprint 18), but those Firefox profiles are incompatible with Chromium.
- Headless execution demands warmed cookies/tokens plus BrowserForge fingerprints to bypass TikVid interaction gates.

## Problem Statement
Without Chromium-specific profiles:
- Every headless launch triggers TikVid's verification flow (manual clicks, fill interactions).
- Session tokens and cookies cannot persist between download attempts.
- There is no separation between write-mode browse sessions and read-mode cloning, inviting profile corruption.

## Objectives
1. Introduce a Chromium user-data directory structure analogous to Camoufox's clone/write model.
2. Enable safe re-use of warmed Chromium sessions from `/browse` headful runs and background download services.
3. Export/import cross-browser cookies when needed without mixing profile file formats.
4. Surface configuration through environment variables and settings objects, respecting the layered architecture.

## Environment Configuration
- **`CHROMIUM_USER_DATA_DIR`** (new): root directory for Chromium profiles. Default proposal: `data/chromium_profiles`.
  - `master/` - canonical write-mode profile, populated by Chromium browse sessions.
  - `clones/<uuid>/` - ephemeral copies for read-mode download tasks (TikTok download strategy, integration tests).

- `CAMOUFOX_USER_DATA_DIR` continues to serve Firefox flows; keep the directories isolated.

## Architecture Overview
1. **Profile Manager**
   - Create `ChromiumUserDataManager` under `app/services/common/browser/user_data_chromium.py`.
   - Mirrors Camoufox context manager semantics: read mode clones master into `/clones/<uuid>`, write mode locks master.
   - Returns `(effective_dir, cleanup_callback)` to callers.
2. **Browse Integration**
   - Chromium browse sessions (triggered through `/browse`) operate in headful mode and write directly to the master profile via `BrowseSessionService`.
   - Service sets runtime flags on settings to signal write-mode before invoking `ChromiumBrowseExecutor`.
3. **Download Strategy**
   - `ChromiumDownloadStrategy._build_chromium_fetch_kwargs` requests read-mode clone from the manager.
   - Injects `additional_args["user_data_dir"] = effective_dir` before toggling `headless=True`.
   - Ensures cleanup callback fires after fetch to delete clone.
4. **Session Refresh Guidance**
   - When additional cookie exports are required, operators can run `Playwright context.storage_state()` against the master profile after closing the browse session.
   - Download strategy may import those cookies before navigation to supplement on-disk profile data.
5. **BrowserForge Integration**
   - During profile creation, run BrowserForge scripts once to seed fingerprint data; store outputs inside master profile.
   - Maintain metadata (`metadata.json`) recording fingerprint version, last refresh timestamp.

## Workflow Scenarios
### A. Seeding Chromium Profile
1. Operator calls `POST /browse` with `{ "engine": "chromium", "mode": "interactive" }`.
2. Service enters write mode, locks `master/`, launches headful Chromium for manual login, and releases lock on exit.

### B. TikTok Download
1. `TikTokDownloadService` instantiates `ChromiumDownloadStrategy`.
2. Strategy requests read-mode clone, launches DynamicFetcher headless with warmed profile, imports latest cookies.
3. On completion, clone cleanup runs and artifacts remain in store for next invocation.

## Functional Requirements
1. `ChromiumDownloadStrategy` must retrieve user data dirs via abstraction (no direct `os.environ` lookups).
2. Clone directories must be removed even on exceptions (finally blocks using cleanup callback).
3. When user-data absent or the env var unset, strategy should log warning and continue in legacy stateless mode.
4. Provide operator-facing guidance on refreshing Chromium sessions manually (documentation + logging).
5. Unit tests must cover manager behaviours (lock handling, cleanup), and integration tests ensure downloads succeed headless with warmed profile.

## Risks & Mitigations
- **Profile corruption**: isolate clones per run; never share clones across concurrent downloads.
- **Lock contention**: implement file-based locking (e.g., `chromium_profile.lock`) for write mode; return 409 to `/browse` on conflict.
- **Disk bloat**: cleanup clones promptly; scheduled job to prune aged directories.
- **Cookie format mismatch**: rely on Playwright's `context.storage_state()` for export/import; sanitize to Chromium schema.

## Testing Strategy
- **Unit**
  - `ChromiumUserDataManager` read/write context behaviours.
  - Settings helpers honour env defaults.
  - Strategy fallback path when user data disabled.
- **Integration (pytest.mark.integration)**
  - Headless download using warmed profile returns MP4 URL.
  - Chromium browse session launches headful, persists cookies, and allows subsequent download success.
  - Concurrent read clones operate safely.
- **Manual QA**
  - Verify manual browse session updates master and persists login.
- Confirm documentation gives operators clear steps for refreshing profiles manually.

## Rollout Plan
1. Confirm no backward compatibility expectations; update browse/download tests to assert Chromium user-data behaviour before rollout.
2. Land user-data manager + settings changes.
3. Update strategy to consume manager and cookies; add tests.
4. Document new env var in `README.md`, `RUN.md`, `.env.example`, `AGENTS.md`.
5. Complete rollout once soak-tested in staging with manual browse workflows.

## Dependencies
- DynamicFetcher availability with Chromium runtime.
- BrowserForge fingerprints for Chromium.
- Existing user data context utilities.
- Settings infrastructure via `pydantic-settings`.
- Sprint 25.1 browse redesign can proceed in parallel; coordinate on shared tests but implementation surfaces do not overlap.

## Acceptance Criteria
- `CHROMIUM_USER_DATA_DIR` drives profile management for Chromium flows.
- Headless TikTok download succeeds using persisted session data without human intervention.
- Headful Chromium browse sessions regenerate cookies visible to the download strategy.
- No regressions to existing Camoufox user-data functionality.

